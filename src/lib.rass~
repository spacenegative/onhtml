#![allow(non_snake_case)]                
use duplicate::duplicate                 
use std::io::prelude::*                  
use std::time::{ SystemTime,UNIX_EPOCH } 

struct Tag                                  
       pub    name:  String ,               
       pub    atts:  Vec<(String,String)> , 
       pub    val:   String ,               

impl   Tag 

       fn     new( name:String , val:String )->Tag 
              return Tag                           
                     name ,                        
                     atts:  vec![] ,               
                     val ,                         

       fn     att( &mut self , name:String , val:String ) -> &mut Self 
              self.atts.push( ( name , val ) )                         
              return self                                              

pub    struct Html                      
       pub title:    String ,           
       pub desc:     String ,           
       pub kws:      Vec<String> ,      
       pub content:  String ,           
       pub theme:    String ,           
       pub scale:    u32 ,              
       pub css:      Vec<String> ,      
       pub js:       Vec<(JS,String)> , 
       pub favicon:  String ,           
pub    enum   JS                        
       Module ,Script ,                 

impl   Html 

       pub    fn     version( &mut self ) -> &mut Html                                                                      
              let t = SystemTime::now().duration_since( UNIX_EPOCH ).expect( "ERR: Time is before Unix Epoch" ).as_millis() 
              let ver = !!( "?v={}" , t )                                                                                   
              for    link in &mut self.css                                                                                  
                     link.push_str( &ver )                                                                                  
              for    script in &mut self.js                                                                                 
                     script .1 .push_str( &ver )                                                                            
              self.favicon.push_str( &ver )                                                                                 
              return self                                                                                                   

       pub    fn     print( &mut self ) -> String                                                                                          
              if     self.desc.len() > 120                                                                                                 
                     panic!( !!( "\n\n\tHtml.desc IS {} CHARS BUT MUST BE UP TO 120\n\n", self.desc.len() ) )                              
              if     self.title.len() > 60                                                                                                 
                     panic!( !!( "\n\n\tHtml.title IS {} CHARS BUT MUST BE UP TO 60\n\n", self.title.len() ) )                             
              if     self.kws.len() > 10                                                                                                   
                     panic!( !!( "\n\n\tHtml.kws HAS {} KEYWORDS, BUT MUST BE UP TO 10\n\n", self.title.len() ) )                          
              let html = self.version()                                                                                                    
              let mut x = !!( "<title>{}</title>\n" , html.title )                                                                         
              x.push_str( "<meta http-equiv='Content-Type' content='text/html; charset=utf-8'>\n" )                                        
              x.push_str( &!!( "<meta name='description' content='{}'>\n" , html.desc ) )                                                  
              if     html.kws.len() > 0                                                                                                    
                     let mut kws = ""`                                                                                                     
                     for    k in &html.kws                                                                                                 
                            kws += &!!( "{}, " , k )                                                                                       
                     let kws = kws[..kws.len()-2]`                                                                                         
                     x.push_str( &!!( "<meta name='keywords' content='{}'>\n" , kws ) )                                                    
              x.push_str( &!!( "<meta name='viewport' content='width=device-width, initial-scale=1, maximum-scale={}'>\n" , html.scale ) ) 
              x.push_str( &!!( "<meta name='theme-color' content='{}'>\n" , html.theme ) )                                                 
              for    i in &html.css                                                                                                        
                     x.push_str( &!!( "<link rel='stylesheet' href='{}' />\n" , i ) )                                                      
              x.push_str( &!!( "<link rel='shortcut icon' href='{}' />\n" , &html.favicon ) )                                              
              x = !!( "<!DOCTYPE html>\n<html>\n{}\n<body>\n{}\n</body>\n" , x , html.content )                                            
              for    i in &html.js                                                                                                         
                     match  i .0                                                                                                           
                            JS::Script =>                                                                                                  
                                   x.push_str( &!!( "<script src='{}'></script>\n" , i .1 ) )                                              
                            JS::Module =>                                                                                                  
                                   x.push_str( &!!( "<script type='module' src='{}'></script>\n" , i .1 ) )                                
              x.push_str( "</html>" )                                                                                                      
              return x                                                                                                                     

       pub    fn     write( &mut self , file:&str )                                                                   
              let p = std::path::Path::new( file )                                                                    
              let mut f = std::fs::File::create( &p ).expect( !!( "ERR: COULD NOT CREATE FILE {}" , file ).as_str() ) 
              let h = self.print()                                                                                    
              f.write_all( h.as_bytes() ).expect( !!("ERR: COULD NOT WRITE TO {}",p.display()).as_str() )             

#[duplicate( T; [B]; [Label]; [Datalist]; [Code]; [Article]; [Aside]; [Section]; [P]; [Ol]; [Ul]; [Li]; [Option]; [Pre]; [Canvas]; [Blockquote]; [Source]; [Span]; [A]; [Form]; [Template]; [Video]; [Textarea]; [Select]; [H1]; [H2]; [H3]; [H4]; [H5]; [H6]; [Button]; [Div]; [Img]; [Input] )]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
pub    struct T( Tag ) ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
#[duplicate(f name T ; [b]["b"][B]; [label]["label"][Label]; [datalist]["datalist"][Datalist]; [code]["code"][Code]; [article]["article"][Article]; [aside]["aside"][Aside]; [section]["section"][Section]; [p]["p"][P]; [ol]["ol"][Ol]; [ul]["ul"][Ul]; [li]["li"][Li]; [option]["option"][Option]; [pre]["pre"][Pre]; [canvas]["canvas"][Canvas]; [blockquote]["blockquote"][Blockquote]; [source]["source"][Source]; [span]["span"][Span]; [a]["a"][A]; [form]["form"][Form]; [template]["template"][Template]; [video]["video"][Video]; [textarea]["textarea"][Textarea]; [select]["select"][Select]; [h1]["h1"][H1]; [h2]["h2"][H2]; [h3]["h3"][H3]; [h4]["h4"][H4]; [h5]["h5"][H5]; [h6]["h6"][H6]; [button]["button"][Button]; [div]["div"][Div]; [img]["img"][Img]; [input]["input"][Input] )] 
pub    fn     f( val:&str ) -> T                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
       let t = Tag::new( name` , val` )                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
       return T( t )                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
#[duplicate(T; [B]; [Label]; [Datalist]; [Code]; [Article]; [Aside]; [Section]; [P]; [Ol]; [Ul]; [Li]; [Option]; [Pre]; [Canvas]; [Blockquote]; [Source]; [Span]; [A]; [Form]; [Template]; [Video]; [Textarea]; [Select]; [H1]; [H2]; [H3]; [H4]; [H5]; [H6]; [Button]; [Div]; [Img]; [Input] )]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       

impl   T 

       pub    fn     id( &mut self , val:&str ) -> &mut Self 
              self.0.att( "id"` , val` )                     
              return self                                    

       pub    fn     class( &mut self , val:&str ) -> &mut Self 
              self.0.att( "class"` , val` )                     
              return self                                       

       pub    fn     onclick( &mut self , val:&str ) -> &mut Self 
              self.0.att( "onclick"` , val` )                     
              return self                                         

       pub    fn     onload( &mut self , val:&str ) -> &mut Self 
              self.0.att( "onload"` , val` )                     
              return self                                        

       pub    fn     data( &mut self , key:&str , val:&str ) -> &mut Self 
              self.0.att( !!( "data-{}",key )` , val` )                   
              return self                                                 

       pub    fn     contenteditable( &mut self ) -> &mut Self 
              self.0.att( "contenteditable"` , "true"` )       
              return self                                      

       pub    fn     tabindex( &mut self ,n:i32 ) -> &mut Self 
              self.0.att( "tabindex"` , !!("{}" ,n) )          
              return self                                      

       pub    fn     autocorrect( &mut self ,b:bool) -> &mut Self 
              if     b                                            
                     self.0.att( "autocorrect"` , "on"` )         
              else                                                
                     self.0.att( "autocorrect"` , "off"` )        
              return self                                         

       pub    fn     autocapitalize( &mut self ,b:bool) -> &mut Self 
              if     b                                               
                     self.0.att( "autocapitalize"` , "on"` )         
              else                                                   
                     self.0.att( "autocapitalize"` , "off"` )        
              return self                                            

       pub    fn     spellcheck( &mut self ,b:bool) -> &mut Self 
              if     b                                           
                     self.0.att( "spellcheck"` , "true"` )       
              else                                               
                     self.0.att( "spellcheck"` , "false"` )      
              return self                                        

       pub    fn     noAutos( &mut self ) -> &mut Self 
              self                                     
              .autocorrect(false)                      
              .autocapitalize(false)                   
              .spellcheck(false)                       
              return self                              

       pub    fn     n( &mut self ) -> String                        
              let mut x = !!( "\n<{} " , self.0.name )               
              for    att in &self.0.atts                             
                     if     att.1 == ""                              
                            x += &!!( "{} " , &att.0 )               
                     else                                            
                            x += &!!( "{}='{}' " , &att.0 , &att.1 ) 
              let val = !!( "\n{}\n" , &self.0.val )                 
              let val = unlines( val.lines().map( tab ).collect() )  
              x += &!!( ">{}</{}>" , &val , &self.0.name )           
              return !!( "{}" , x )                                  

//     ENUMS                                                                                                                                          
pub    enum   TextareaWrap                                                                                                                            
       Hard,Soft,                                                                                                                                     
pub    enum   Type                                                                                                                                    
       Button,Checkbox,Color,Date,DatetimeLocal,Email,File,Hidden,Image,Month,Number,Password,Radio,Range,Reset,Search,Submit,Tel,Text,Time,Url,Week, 
pub    enum   Preload                                                                                                                                 
       Auto,Metadata,None,                                                                                                                            
pub    enum   Enctype                                                                                                                                 
       Application,Multipart,Text,                                                                                                                    
pub    enum   Method                                                                                                                                  
       Get,Post,                                                                                                                                      
pub    enum   Target                                                                                                                                  
       Blank,Self_,Parent,Top,                                                                                                                        
pub    enum   FormRel                                                                                                                                 
       External,Help,License,Next,Nofollow,Noopener,Noreferrer,Opener,Prev,Search,	                                                                   
pub    enum   ARel                                                                                                                                    
       Alternate ,Author ,Bookmark ,External ,Help ,License ,Next ,Nofollow ,Noreferrer ,Noopener ,Prev ,Search ,Tag ,                                
pub    enum   Refpolicy                                                                                                                               
       NoReferrer ,NoReferrerWhenDowngrade ,Origin ,OriginWhenCrossOrigin ,UnsafeUrl ,                                                                
pub    enum   ListType                                                                                                                                
       N ,A ,Aa ,I ,Ii ,                                                                                                                              


impl   Li 

       pub    fn     value( &mut self ,n:u32) -> &mut Self 
              self.0.att( "value"` , !!("{}" ,n))          
              return self                                  

impl   Label 

       pub    fn     for_( &mut self ,x:&str) -> &mut Self      
              self.0.att( "for"` , !!("{}" ,x))                 
              return self                                       
//     Only for <ol> lists.                                     
//     Specifies the start value of a list item.                
//     The following list items will increment from that number 

impl   Pre 

       pub    fn     oninput( &mut self ,f:&str) -> &mut Self 
              self.0.att( "oninput"` , !!("{}" ,f))           
              return self                                     

       pub    fn     onchange( &mut self ,f:&str) -> &mut Self 
              self.0.att( "onchange"` , !!("{}" ,f))           
              return self                                      

       pub    fn     wrap( &mut self ) -> &mut Self 
              self.0.att( "wrap"` , ""`)            
              return self                           

impl   Ol 

       pub    fn     reversed( &mut self ) -> &mut Self 
              self.0.att( "reversed"` , ""` )           
              return self                               

       pub    fn     start( &mut self ,n:u32) -> &mut Self  
              self.0.att( "start"` , !!("{}" ,n) )          
              return self                                   
       /* Specifies the start value of an ordered list */;; 

       pub    fn     type_( &mut self ,t:ListType) -> &mut Self 
              match  t                                          
                     ListType::N =>                             
                            self.0.att( "type"` ,"1"` )         
                            return self                         
                     ListType::A =>                             
                            self.0.att( "type"` ,"A"` )         
                            return self                         
                     ListType::Aa =>                            
                            self.0.att( "type"` ,"a"` )         
                            return self                         
                     ListType::I =>                             
                            self.0.att( "type"` ,"I"` )         
                            return self                         
                     ListType::Ii =>                            
                            self.0.att( "type"` ,"i"` )         
                            return self                         
       /* Specifies the start value of an ordered list */;;     

impl   A 

       pub    fn     download( &mut self ) -> &mut Self 
              self.0.att( "download"` , ""` )           
              return self                               

       pub    fn     href( &mut self , url:&str ) -> &mut Self 
              self.0.att( "href"` , url` )                     
              return self                                      

       pub    fn     type_( &mut self , x:&str ) -> &mut Self 
              self.0.att( "type"` , x` )                      
              return self                                     

       pub    fn     hreflang( &mut self , two_digit_code:&str ) -> &mut Self 
              self.0.att( "hreflang"` , two_digit_code` )                     
              return self                                                     

       pub    fn     ping( &mut self , urls:&str ) -> &mut Self 
              self.0.att( "hreflang"` , urls` )                 
              return self                                       
              /* space separated urls */ ;;                     

       pub    fn     target( &mut self , x:Target ) -> &mut Self 
              match  x                                           
                     Target::Blank =>                            
                            self.0.att( "target"` , "blank"` )   
                            return self                          
                     Target::Parent =>                           
                            self.0.att( "target"` , "parent"` )  
                            return self                          
                     Target::Self_ =>                            
                            self.0.att( "target"` , "self"` )    
                            return self                          
                     Target::Top =>                              
                            self.0.att( "target"` , "top"` )     
                            return self                          

       pub    fn     rel( &mut self , x:ARel ) -> &mut Self      
              match  x                                           
                     ARel::Alternate =>                          
                            self.0.att( "rel"` , "alternate"` )  
                            return self                          
                     ARel::Author =>                             
                            self.0.att( "rel"` , "author"` )     
                            return self                          
                     ARel::Bookmark =>                           
                            self.0.att( "rel"` , "bookmark"` )   
                            return self                          
                     ARel::External =>                           
                            self.0.att( "rel"` , "external"` )   
                            return self                          
                     ARel::Help =>                               
                            self.0.att( "rel"` , "help"` )       
                            return self                          
                     ARel::License =>                            
                            self.0.att( "rel"` , "license"` )    
                            return self                          
                     ARel::Next =>                               
                            self.0.att( "rel"` , "next"` )       
                            return self                          
                     ARel::Nofollow =>                           
                            self.0.att( "rel"` , "nofollow"` )   
                            return self                          
                     ARel::Noreferrer =>                         
                            self.0.att( "rel"` , "noreferrer"` ) 
                            return self                          
                     ARel::Noopener =>                           
                            self.0.att( "rel"` , "noopener"` )   
                            return self                          
                     ARel::Prev =>                               
                            self.0.att( "rel"` , "prev"` )       
                            return self                          
                     ARel::Search =>                             
                            self.0.att( "rel"` , "search"` )     
                            return self                          
                     ARel::Tag =>                                
                            self.0.att( "rel"` , "tag"` )        
                            return self                          

       pub    fn     novalidate( &mut self ) -> &mut Self 
              self.0.att( "novalidate"` , ""` )           
              return self                                 

       pub    fn     name( &mut self , x:&str ) -> &mut Self 
              self.0.att( "name"` , x` )                     
              return self                                    

       pub    fn     action( &mut self , url:&str ) -> &mut Self 
              self.0.att( "action"` , url` )                     
              return self                                        

       pub    fn     method( &mut self , x:Method ) -> &mut Self 
              match  x                                           
                     Method::Get =>                              
                            self.0.att( "method"` , "get"` )     
                            return self                          
                     Method::Post =>                             
                            self.0.att( "method"` , "post"` )    
                            return self                          

       pub    fn     enctype( &mut self , x:Enctype ) -> &mut Self                          
              match  x                                                                      
                     Enctype::Application =>                                                
                            self.0.att( "enctype"` , "application/x-www-form-urlencoded"` ) 
                            return self                                                     
                     Enctype::Multipart =>                                                  
                            self.0.att( "enctype"` , "multipart/form-data"` )               
                            return self                                                     
                     Enctype::Text =>                                                       
                            self.0.att( "enctype"` , "text/plain"` )                        
                            return self                                                     

       pub    fn     autocomplete( &mut self , on:bool ) -> &mut Self 
              if     on                                               
                     self.0.att( "autocomplete"` , "on"` )            
              else                                                    
                     self.0.att( "autocomplete"` , "off"` )           
              return self                                             

impl   Form 

       pub    fn     target( &mut self , x:Target ) -> &mut Self 
              match  x                                           
                     Target::Blank =>                            
                            self.0.att( "rel"` , "_blank"` )     
                            return self                          
                     Target::Self_ =>                            
                            self.0.att( "rel"` , "_self"` )      
                            return self                          
                     Target::Parent =>                           
                            self.0.att( "rel"` , "_parent"` )    
                            return self                          
                     Target::Top =>                              
                            self.0.att( "rel"` , "_top"` )       
                            return self                          

       pub    fn     rel( &mut self , x:FormRel ) -> &mut Self   
              match  x                                           
                     FormRel::External =>                        
                            self.0.att( "rel"` , "external"` )   
                            return self                          
                     FormRel::Help =>                            
                            self.0.att( "rel"` , "help"` )       
                            return self                          
                     FormRel::License =>                         
                            self.0.att( "rel"` , "license"` )    
                            return self                          
                     FormRel::Next =>                            
                            self.0.att( "rel"` , "next"` )       
                            return self                          
                     FormRel::Nofollow =>                        
                            self.0.att( "rel"` , "nofollow"` )   
                            return self                          
                     FormRel::Noopener =>                        
                            self.0.att( "rel"` , "noopener"` )   
                            return self                          
                     FormRel::Noreferrer =>                      
                            self.0.att( "rel"` , "noreferrer"` ) 
                            return self                          
                     FormRel::Opener =>                          
                            self.0.att( "rel"` , "opener"` )     
                            return self                          
                     FormRel::Prev =>                            
                            self.0.att( "rel"` , "prev"` )       
                            return self                          
                     FormRel::Search =>                          
                            self.0.att( "rel"` , "search"` )     
                            return self                          

       pub    fn     novalidate( &mut self ) -> &mut Self 
              self.0.att( "novalidate"` , ""` )           
              return self                                 

       pub    fn     name( &mut self , x:&str ) -> &mut Self 
              self.0.att( "name"` , x` )                     
              return self                                    

       pub    fn     onsubmit( &mut self ,f:&str ) -> &mut Self 
              self.0.att( "onsubmit"` , f` )                    
              return self                                       

       pub    fn     action( &mut self , url:&str ) -> &mut Self 
              self.0.att( "action"` , url` )                     
              return self                                        

       pub    fn     method( &mut self , x:Method ) -> &mut Self 
              match  x                                           
                     Method::Get =>                              
                            self.0.att( "method"` , "get"` )     
                            return self                          
                     Method::Post =>                             
                            self.0.att( "method"` , "post"` )    
                            return self                          

       pub    fn     enctype( &mut self , x:Enctype ) -> &mut Self                          
              match  x                                                                      
                     Enctype::Application =>                                                
                            self.0.att( "enctype"` , "application/x-www-form-urlencoded"` ) 
                            return self                                                     
                     Enctype::Multipart =>                                                  
                            self.0.att( "enctype"` , "multipart/form-data"` )               
                            return self                                                     
                     Enctype::Text =>                                                       
                            self.0.att( "enctype"` , "text/plain"` )                        
                            return self                                                     

       pub    fn     autocomplete( &mut self , on:bool ) -> &mut Self 
              if     on                                               
                     self.0.att( "autocomplete"` , "on"` )            
              else                                                    
                     self.0.att( "autocomplete"` , "off"` )           
              return self                                             

impl   Img 

       pub    fn     src( &mut self , val:&str ) -> &mut Self 
              self.0.att( "src"` , val` )                     
              return self                                     

impl   Source 

       pub    fn     src( &mut self , val:&str ) -> &mut Self 
              self.0.att( "src"` , val` )                     
              return self                                     

impl   Video 

       pub    fn     preload( &mut self , x:Preload ) -> &mut Self 
              match  x                                             
                     Preload::Auto =>                              
                            self.0.att( "preload"` , "auto"` )     
                            return self                            
                     Preload::Metadata =>                          
                            self.0.att( "preload"` , "metadata"` ) 
                            return self                            
                     Preload::None =>                              
                            self.0.att( "preload"` , "none"` )     
                            return self                            

       pub    fn     autoplay( &mut self ) -> &mut Self 
              self.0.att( "autoplay"` , ""` )           
              return self                               

       pub    fn     controls( &mut self ) -> &mut Self 
              self.0.att( "controls"` , ""` )           
              return self                               

       pub    fn     loop_( &mut self ) -> &mut Self 
              self.0.att( "loop"` , ""` )            
              return self                            

       pub    fn     muted( &mut self ) -> &mut Self 
              self.0.att( "muted"` , ""` )           
              return self                            

       pub    fn     poster( &mut self ,url:&str ) -> &mut Self 
              self.0.att( "poster"` , url` )                    
              return self                                       

       pub    fn     src( &mut self ,url:&str ) -> &mut Self 
              self.0.att( "src"` , url` )                    
              return self                                    

       pub    fn     width( &mut self , x:i32 ) -> &mut Self 
              self.0.att( "width"` , x` )                    
              return self                                    

       pub    fn     height( &mut self , x:i32 ) -> &mut Self 
              self.0.att( "height"` , x` )                    
              return self                                     

impl   Select 

       pub    fn     autofocus( &mut self ) -> &mut Self 
              self.0.att( "autofocus"` , ""` )           
              return self                                

       pub    fn     disabled( &mut self ) -> &mut Self 
              self.0.att( "disabled"` , ""` )           
              return self                               

       pub    fn     required( &mut self ) -> &mut Self 
              self.0.att( "required"` , ""` )           
              return self                               

       pub    fn     name( &mut self , x:&str ) -> &mut Self 
              self.0.att( "name"` , x` )                     
              return self                                    

       pub    fn     size( &mut self , x:i32 ) -> &mut Self 
              self.0.att( "size"` , !!( "{}",x ) )          
              return self                                   

       pub    fn     onchange( &mut self ,f:&str ) -> &mut Self 
              self.0.att( "onchange"` , f` )                    
              return self                                       

impl   Option 

       pub    fn     disabled( &mut self ) -> &mut Self 
              self.0.att( "disabled"` , ""` )           
              return self                               

       pub    fn     selected( &mut self ) -> &mut Self 
              self.0.att( "selected"` , ""` )           
              return self                               

       pub    fn     value( &mut self , x:&str ) -> &mut Self 
              self.0.att( "value"` , x` )                     
              return self                                     

impl   Button 

       pub    fn     autofocus( &mut self ) -> &mut Self 
              self.0.att( "autofocus"` , ""` )           
              return self                                

       pub    fn     disabled( &mut self ) -> &mut Self 
              self.0.att( "disabled"` , ""` )           
              return self                               

       pub    fn     name( &mut self , x:&str ) -> &mut Self 
              self.0.att( "name"` , x` )                     
              return self                                    

       pub    fn     value( &mut self , x:&str ) -> &mut Self 
              self.0.att( "value"` , x` )                     
              return self                                     

impl   Input 

       pub    fn     minlenght( &mut self , val:i32 ) -> &mut Self 
              self.0.att( "minlenght"` , !!("{}" , val` ) )        
              return self                                          

       pub    fn     value( &mut self , val:&str ) -> &mut Self 
              self.0.att( "value"` , !!("{}" , val` ) )         
              return self                                       

       pub    fn     size( &mut self , val:i32 ) -> &mut Self 
              self.0.att( "size"` , !!("{}" , val` ) )        
              return self                                     

       pub    fn     max( &mut self , val:&str ) -> &mut Self 
              self.0.att( "max"` , val` )                     
              return self                                     

       pub    fn     list( &mut self , id:&str ) -> &mut Self 
              self.0.att( "list"` , id` )                     
              return self                                     
       //     id of the datalist tag (input autocompletion)   

       pub    fn     name( &mut self , val:&str ) -> &mut Self 
              self.0.att( "name"` , val` )                     
              return self                                      

       pub    fn     placeholder( &mut self , val:&str ) -> &mut Self 
              self.0.att( "placeholder"` , val` )                     
              return self                                             

       pub    fn     readonly( &mut self ) -> &mut Self 
              self.0.att( "readonly"` , ""` )           
              return self                               

       pub    fn     min( &mut self , val:&str ) -> &mut Self 
              self.0.att( "min"` , val` )                     
              return self                                     

       pub    fn     checked( &mut self ) -> &mut Self 
              self.0.att( "checked"` , ""` )           
              return self                              

       pub    fn     autofocus( &mut self ) -> &mut Self 
              self.0.att( "autofocus"` , ""` )           
              return self                                

       pub    fn     disabled( &mut self ) -> &mut Self 
              self.0.att( "disabled"` , ""` )           
              return self                               

       pub    fn     autocomplete( &mut self , val:bool ) -> &mut Self 
              if     val                                               
                     self.0.att( "autocomplete"` , "on"` )             
              else                                                     
                     self.0.att( "autocomplete"` , "off"` )            
              return self                                              

       pub    fn     alt( &mut self , val:&str ) -> &mut Self                              
              let mut b = false                                                            
              for    a in &self.0.atts                                                     
                     if     a.0 == "type" && a.1 == "image"                                
                            b = true                                                       
              self.0.att( "accept"` , val` )                                               
              if     !b                                                                    
                     panic!( "\n\nTHE 'alt' ATT IS ONLY VALID FOR ATT: type='image'\n\n" ) 
              return self                                                                  

       pub    fn     accept( &mut self , val:&str ) -> &mut Self                             
              let mut b = false                                                              
              for    a in &self.0.atts                                                       
                     if     a.0 == "type" && a.1 == "text"                                   
                            b = true                                                         
              self.0.att( "accept"` , val` )                                                 
              if     !b                                                                      
                     panic!( "\n\nTHE 'accept' ATT IS ONLY VALID FOR ATT: type='text'\n\n" ) 
              return self                                                                    

       pub    fn     type_( &mut self , val:Type ) -> &mut Self      
              match  val                                             
                     Type::Button =>                                 
                            self.0.att( "type"` , "button"` )        
                            return self                              
                     Type::Checkbox =>                               
                            self.0.att( "type"` , "checkbox"` )      
                            return self                              
                     Type::Color =>                                  
                            self.0.att( "type"` , "color"` )         
                            return self                              
                     Type::Date =>                                   
                            self.0.att( "type"` , "date"` )          
                            return self                              
                     Type::DatetimeLocal =>                          
                            self.0.att( "type"` , "datetimeLocal"` ) 
                            return self                              
                     Type::Email =>                                  
                            self.0.att( "type"` , "email"` )         
                            return self                              
                     Type::File =>                                   
                            self.0.att( "type"` , "file"` )          
                            return self                              
                     Type::Hidden =>                                 
                            self.0.att( "type"` , "hidden"` )        
                            return self                              
                     Type::Image =>                                  
                            self.0.att( "type"` , "image"` )         
                            return self                              
                     Type::Month =>                                  
                            self.0.att( "type"` , "month"` )         
                            return self                              
                     Type::Number =>                                 
                            self.0.att( "type"` , "number"` )        
                            return self                              
                     Type::Password =>                               
                            self.0.att( "type"` , "password"` )      
                            return self                              
                     Type::Radio =>                                  
                            self.0.att( "type"` , "radio"` )         
                            return self                              
                     Type::Range =>                                  
                            self.0.att( "type"` , "range"` )         
                            return self                              
                     Type::Reset =>                                  
                            self.0.att( "type"` , "reset"` )         
                            return self                              
                     Type::Search =>                                 
                            self.0.att( "type"` , "search"` )        
                            return self                              
                     Type::Submit =>                                 
                            self.0.att( "type"` , "submit"` )        
                            return self                              
                     Type::Tel =>                                    
                            self.0.att( "type"` , "tel"` )           
                            return self                              
                     Type::Text =>                                   
                            self.0.att( "type"` , "text"` )          
                            return self                              
                     Type::Time =>                                   
                            self.0.att( "type"` , "time"` )          
                            return self                              
                     Type::Url =>                                    
                            self.0.att( "type"` , "url"` )           
                            return self                              
                     Type::Week =>                                   
                            self.0.att( "type"` , "week"` )          
                            return self                              

       pub    fn     onchange( &mut self ,f:&str ) -> &mut Self 
              self.0.att( "onchange"` , f` )                    
              return self                                       

       pub    fn     oninput( &mut self ,f:&str ) -> &mut Self 
              self.0.att( "onchange"` , f` )                   
              return self                                      

impl   Textarea 

       pub    fn     autofocus( &mut self ) -> &mut Self 
              self.0.att( "autofocus"` , ""` )           
              return self                                

       pub    fn     disabled( &mut self ) -> &mut Self 
              self.0.att( "disabled"` , ""` )           
              return self                               

       pub    fn     readonly( &mut self ) -> &mut Self 
              self.0.att( "readonly"` , ""` )           
              return self                               

       pub    fn     required( &mut self ) -> &mut Self 
              self.0.att( "required"` , ""` )           
              return self                               

       pub    fn     cols( &mut self , x:i32 ) -> &mut Self 
              self.0.att( "cols"` , !!( "{}",x )` )         
              return self                                   

       pub    fn     rows( &mut self , x:i32 ) -> &mut Self 
              self.0.att( "rows"` , !!( "{}",x )` )         
              return self                                   

       pub    fn     maxlength( &mut self , x:i32 ) -> &mut Self 
              self.0.att( "maxlength"` , !!( "{}",x )` )         
              return self                                        

       pub    fn     name( &mut self , x:&str ) -> &mut Self 
              self.0.att( "name"` , x` )                     
              return self                                    

       pub    fn     placeholder( &mut self , x:&str ) -> &mut Self 
              self.0.att( "placeholder"` , x` )                     
              return self                                           

        pub    fn     onchange( &mut self ,f:&str ) -> &mut Self 
              self.0.att( "onchange"` , f` )                     
              return self                                        

       pub    fn     oninput( &mut self , f:&str ) -> &mut Self 
              self.0.att( "oninput"` , f` )                     
              return self                                       

//     HELPERS 

fn     tab( x:&str ) -> String 
       //let mut y = "\t"`     
       let mut y = ""`         
       y.push_str( x )         
       return y                

fn     unlines( ls:Vec<String> ) -> String 
       let mut x = ""`                     
       for    l in ls                      
              x.push_str( &l )             
              x.push_str( "\n" )           
       return x[..x.len()-1]`              

//     READY CONTRUCTS 

pub    fn     paged( pages:Vec<String> ) -> String                     
       let mut pagernav = input( "" ) .class( "term" ) .n()            
       pagernav += &form( &pagernav ).class( "hidden" ).n()            
       let pager = div( "" ).class( "pager" ).n()                      
       pagernav += &pager                                              
       pagernav += &div( &pagernav ).class( "nav" ).n()                
       for    page in pages                                            
              pagernav += &div( &page ).class( "page" ).n()            
       let paged = div( &pagernav ).class( "paged" ).id( "PAGED" ).n() 
       return paged                                                    

//     REFERENCE                                  
//     https://www.w3schools.com/TAGS/default.ASP 

